# DeepSeek PageIndex RAG Test

This project is a sophisticated, GUI-driven system for building and querying a Retrieval-Augmented Generation (RAG) pipeline, specifically tailored for industrial documents. It provides a suite of tools to parse PDFs, vectorize their content, and perform advanced hybrid searches to answer complex queries.

## Features

-   **GUI-Driven Data Pipeline**: A user-friendly PyQt5 application to manage the entire data preparation process, from PDF parsing to vectorization.
-   **Advanced RAG Architecture**: Implements a modern, robust hybrid search pipeline, including:
    -   **Query Rewriting**: Utilizes a Large Language Model (LLM) to transform simple user queries into more detailed, semantically rich questions.
    -   **Hybrid Search**: Combines dense vector retrieval with traditional keyword-based (sparse) search for more accurate results.
    -   **Reciprocal Rank Fusion (RRF)**: Merges the results from different retrieval methods into a single, relevance-ranked list.
    -   **Reranking**: A final reranking step to ensure the most relevant documents are prioritized.
-   **Asynchronous Operations**: The GUI uses threads and subprocesses to run long-running tasks, ensuring the application remains responsive.
-   **Knowledge Recall UI**: A separate utility for manually loading, searching, and exploring the structured JSON data generated by the pipeline.
-   **Export Functionality**: The ability to export processed data to various formats, including DOCX, TXT, CSV, and XLSX.

## Code Structure

The project is organized into several key files:

-   `pgui.py`: The main GUI application for the data preparation pipeline. It handles PDF parsing, vectorization, and orchestrates the overall workflow.
-   `RAG_Backend.py`: The core of the retrieval system. It contains the logic for query rewriting, hybrid search, RRF, reranking, and final answer generation.
-   `pgirecallwindow.py`: A separate PyQt5 application for manually exploring and searching the structured JSON files generated by `pgui.py`.
-   `requirements.txt`: A list of all the Python dependencies required to run the project.
-   `pageindex/`: A directory containing modules related to the PageIndex data structure.
-   `QwenAPIutilspy/`: A directory containing utility functions for interacting with the Qwen API.

## Key Algorithms

### 1. Hybrid Search

The system combines two main search strategies:

-   **Vector Search**: Documents are converted into numerical vectors (embeddings), and a query vector is used to find the most similar documents based on cosine similarity. This is effective for finding semantically related content.
-   **Keyword Search**: A traditional keyword search is performed on the original JSON data. This is useful for finding exact matches and specific terms.

### 2. Reciprocal Rank Fusion (RRF)

RRF is used to merge the results from the vector and keyword searches. It's a "rank-based" fusion method that is simple yet highly effective. The score for each document is calculated as:

```
RRF_Score = sum(1 / (k + rank_i))
```

where `rank_i` is the rank of the document in the `i`-th result list, and `k` is a constant (usually 60). This method is less sensitive to the absolute scores of the individual search methods and focuses on the relative ranking of the results.

## Data Structures

The primary data structure in this project is the **PageIndex JSON**. This is a structured JSON file that represents the content of a parsed PDF. It has a hierarchical structure, with each node representing a section of the document. A typical node has the following fields:

-   `node_id`: A unique identifier for the node.
-   `title`: The title of the section.
-   `text`: The raw text content of the section.
-   `summary`: An AI-generated summary of the section.
-   `nodes`: A list of child nodes, representing subsections.

This structured format is used for both the keyword search and as the source for the vectorization process.
